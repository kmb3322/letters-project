<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>timetogotobed</title>

    <!-- Ubuntu Mono for terminal -->
    <link
      href="https://fonts.googleapis.com/css2?family=Ubuntu+Mono&display=swap"
      rel="stylesheet"
    />

    <style>
      html, body { 
        height: 100%; 
        margin: 0;
        overflow: hidden;
      }
      body {
        background: #e2e2e2;
        color: #111;
        line-height: 1.35;
        font-family: "Apple Garamond", serif;
        font-size: 10pt;
        transition: background-color 1.5s ease;
      }
      body.dark {
        background: #000;
        color: #fff;
      }

      /* sun 모드에서의 약한 노란 글로우 */
      body.sun-glow {
        background: radial-gradient(
          circle at 50% 50%,
          rgba(255,220,100,0.18) 0%,
          rgba(0,0,0,1) 70%
        );
        color: #fff;
      }

      #canvas-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1;
      }
      #canvas-container canvas {
        transition: opacity 0.3s ease;
      }

      /* typing indicator: 현재 타이핑 중인 버퍼 */
      #typing-indicator {
        position: fixed;
        left: 50%;
        bottom: 40px;
        transform: translateX(-50%);
        color: #111;
        font-size: 14pt;
        z-index: 10;
        pointer-events: none;
        min-height: 20px;
        letter-spacing: 0.5px;
      }
      /* larger prompt style used in Moon mode for ENTER/TYPE */
      #typing-indicator.typing-big {
        font-size: 28pt;
        letter-spacing: 3px;
        opacity: 0.85;
      }
      body.dark #typing-indicator {
        color: #fff;
      }

      /* title */
      .top-title {
        position: fixed;
        left: 50%;
        top: 22px;
        transform: translateX(-50%);
        color: #111;
        font-size: 10px;
        z-index: 10;
        pointer-events: auto;
        cursor: pointer;
        opacity: 0.7;
        transition: opacity 0.2s ease;
      }
      .top-title:hover {
        opacity: 1;
      }
      body.dark .top-title {
        color: #fff;
      }

      /* preset words (left) */
      #preset {
        position: fixed;
        left: 20px;
        top: 20px;
        z-index: 10;
        color: #111;
        font-size: 12px;
        line-height: 1.6;
        pointer-events: auto;
        transition: opacity 0.6s ease;
      }
      body.dark #preset {
        color: #fff;
      }
      #preset .word {
        opacity: 0.75;
      }
      #preset .word { cursor: pointer; }
      #preset .word.primary { text-decoration: underline; }
      #preset .word:hover { opacity: 1; }

      /* minbeom link */
      .site-link {
        position: fixed;
        left: 50%;
        bottom: 10px;
        transform: translateX(-50%);
        color: #111;
        text-decoration: none;
        font-size: 9px;
        z-index: 10;
      }
      body.dark .site-link {
        color: #fff;
      }

      /* bed 모드: 큰 침대 이미지 (2/3 viewport width, 상하 여백 조금 남김) */
      #bed-wrapper {
        position: fixed;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        z-index: 6;
        display: none;
        width: 66vw;
        max-width: 66vw;
        max-height: 80vh;
      }
      #bed-image {
        width: 100%;
        height: auto;
        max-height: 80vh;
        display: block;
        object-fit: cover;
        image-rendering: crisp-edges;
        border: 0;
      }

      /* monolith: 날카로운 직사각형, 그림자 없음 */
      #monolith {
        position: fixed;
        left: 50%;
        top: 50%; /* 변경: bottom -> top */
        transform: translate(-50%, -50%); /* 변경: X축 -> X,Y축 중앙 정렬 */
        width: 0; /* 변경: 40px -> 0 */
        height: 0;
        background: linear-gradient(to bottom, #1a1a1a 0%, #000 100%);
        z-index: 7;
        /* 변경: width 트랜지션 추가 */
        transition: width 0.08s linear, height 0.08s linear;
        box-shadow: none;
        display: none; /* bed 모드에서만 보임 */
      }

      /* blackout: 정사각형이 화면 전체로 팽창 */
      #blackout {
        position: fixed;
        left: 50%;
        top: 50%;
        width: 200vmax;
        height: 200vmax;
        background: #000;
        transform: translate(-50%, -50%) scale(0);
        transition: transform 0.6s cubic-bezier(0.2,0.8,0.4,1);
        z-index: 900;
        pointer-events: none;
        visibility: hidden;
      }
      #blackout.active {
        visibility: visible;
        transform: translate(-50%, -50%) scale(1);
      }

      /* terminal: 해커 스타일 Q/A */
      #terminal {
        position: fixed;
        left: 20px;
        top: 20px;
        z-index: 1000;
        color: #9aff6a;
        font-family: "Ubuntu Mono", monospace;
        font-size: 14px;
        line-height: 1.4;
        white-space: pre-wrap;
        display: none;
        max-width: 90vw;
        max-height: 90vh;
        overflow: auto;
      }
      #terminal.active {
        display: block;
      }
      .term-line {
        margin: 0;
        padding: 0;
      }
      .cursor {
        display: inline-block;
        width: 8px;
        height: 1em;
        background: #9aff6a;
        margin-left: 2px;
        animation: blink 0.8s step-start infinite;
        vertical-align: bottom;
      }
      @keyframes blink {
        50% { opacity: 0; }
      }
      
      /* terminal exit hint */
      #terminal-exit-hint {
        position: fixed;
        left: 50%;
        bottom: 10px;
        transform: translateX(-50%);
        color: #9aff6a;
        font-family: "Ubuntu Mono", monospace;
        font-size: 11px;
        z-index: 1001;
        display: none;
        opacity: 0.6;
      }
      #terminal-exit-hint.active {
        display: block;
      }
      
      /* center content for special words (Moon, Star) */
      #center-content {
        position: fixed;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        z-index: 950;
        display: none;
      }
      #center-content.active {
        display: block;
      }
      #center-content iframe {
        border: none;
      }
      #center-content img {
        max-width: 90vw;
        max-height: 90vh;
        display: block;
      }
      #center-content .fade-msg {
        color: #fff;
        font-size: 14px;
        text-align: center;
        opacity: 0;
        transition: opacity 1.2s ease;
      }
      
      /* back hint for center content */
      #back-hint {
        position: fixed;
        left: 50%;
        bottom: 30px;
        transform: translateX(-50%);
        color: #111;
        font-size: 11px;
        z-index: 951;
        display: none;
        opacity: 0.6;
      }
      body.dark #back-hint {
        color: #fff;
      }
      #back-hint.active {
        display: block;
      }

      /* onboarding hints */
      .hint {
        position: fixed;
        left: 50%;
        bottom: 70px;
        transform: translateX(-50%);
        color: #111;
        font-family: "Apple Garamond", serif;
        font-size: 11px;
        letter-spacing: 0.5px;
        z-index: 20;
        opacity: 0;
        transition: opacity 0.6s ease;
        pointer-events: none;
      }
      body.dark .hint {
        color: #fff;
      }
      .hint.visible {
        opacity: 1;
      }

      /* Moon story overlay (right center) */
      #moon-story {
        position: fixed;
        right: 5%;
        top: 50%;
        transform: translateY(-50%);
        z-index: 960;
        display: none;
        max-width: 40vw;
        color: inherit;
      }
      #moon-story.active { display: block; }
      #moon-line {
        font-size: 18px;
        letter-spacing: 0.3px;
        opacity: 0;
        transition: opacity 1100ms ease;
      }
      #moon-line.visible { opacity: 1; }
      #moon-prompt {
        margin-top: 14px;
        font-size: 28px;
        opacity: 0.5;
        letter-spacing: 2px;
      }
      #moon-input-value { display: none; }
      
      /* countdown caption under the sphere */
      #countdown-caption {
        position: fixed;
        left: 50%;
        top: calc(50% + 200px);
        transform: translateX(-50%);
        z-index: 955;
        font-size: 14px;
        opacity: 0;
        transition: opacity 1500ms ease;
        pointer-events: none;
        color: inherit;
      }
      #countdown-caption.visible { opacity: 1; }

      /* countdown numbers under the sphere */
      #countdown-number {
        position: fixed;
        left: 50%;
        top: calc(50% + 160px);
        transform: translateX(-50%);
        z-index: 956;
        font-size: 24px;
        letter-spacing: 1px;
        opacity: 0;
        transition: opacity 300ms ease;
        pointer-events: none;
        color: inherit;
      }
      #countdown-number.visible { opacity: 1; }

      /* sun idle hint (center-bottom) */
      #sun-idle-hint {
        position: fixed;
        left: 50%;
        bottom: 34px;
        transform: translateX(-50%);
        color: #fff;
        font-size: 12px;
        opacity: 0;
        transition: opacity 0.6s ease;
        pointer-events: none;
        z-index: 951;
      }
      body:not(.dark) #sun-idle-hint { color: #111; }
      #sun-idle-hint.visible { opacity: 1; }
    </style>
  </head>
  <body>
    <div class="top-title">timetogotobed</div>

    <div id="preset" aria-hidden="true">
      <div id="star-trigger" class="word">Star</div>
      <div id="sun-trigger" class="word">Sun</div>
      <div id="bed-trigger" class="word">Bed</div>
      <div id="moon-trigger" class="word">Moon</div>
    </div>

    <!-- bed mode content -->
    <div id="bed-wrapper">
      <img id="bed-image" src="./public/bed.jpg" alt="bed scene" />
    </div>

    <div id="monolith"></div>

    <!-- main 3D canvas -->
    <div id="canvas-container"></div>

    <!-- typing buffer preview -->
    <div id="typing-indicator"></div>

    <!-- blackout square that expands to full screen -->
    <div id="blackout"></div>

    <!-- terminal overlay (after blackout fills) -->
    <div id="terminal">
      <div id="terminal-content"></div>
    </div>
    
    <!-- terminal exit hint -->
    <div id="terminal-exit-hint">type 'exit' to sleep</div>
    
    <!-- center content for special words -->
    <div id="center-content"></div>

    <!-- Moon story overlay -->
    <div id="moon-story">
      <div id="moon-line"></div>
      <div id="moon-prompt"></div>
      <div id="moon-input-value"></div>
    </div>
    
    <!-- countdown caption (Moon countdown) -->
    <div id="countdown-caption"></div>
    <div id="countdown-number"></div>
    <div id="sun-idle-hint">...feel the light at the core...</div>
    
    <!-- back hint -->
    <div id="back-hint">press enter to exit</div>

    <!-- onboarding hints -->
    <div id="hint-drag" class="hint" aria-hidden="true">Drag To Move Space</div>
    <div id="hint-scroll" class="hint" aria-hidden="true">Scroll To Change Size</div>
    <div id="hint-type" class="hint" aria-hidden="true">Type</div>
    <div id="hint-type-star" class="hint" aria-hidden="true">Type Star</div>

    <a class="site-link" href="https://minbeomkim.com" target="_blank" rel="noopener">MinbeomKim.com</a>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from 'three';
      import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
      import { FontLoader } from 'three/addons/loaders/FontLoader.js';
      import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

      // ====== 3D 기본 세팅 ======
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        50,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.z = 8;

      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      document.getElementById('canvas-container').appendChild(renderer.domElement);

      const clock = new THREE.Clock();

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.enableZoom = false;
      controls.enablePan = false;

      // Light
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
      directionalLight.position.set(5, 5, 5);
      scene.add(directionalLight);

      // DOM refs
      const typingIndicator = document.getElementById('typing-indicator');
      const monolith = document.getElementById('monolith');
      const bedWrapper = document.getElementById('bed-wrapper');
      const bedImage = document.getElementById('bed-image');
      const blackoutEl = document.getElementById('blackout');
      const terminalEl = document.getElementById('terminal');
      const terminalContentEl = document.getElementById('terminal-content');
      const terminalExitHint = document.getElementById('terminal-exit-hint');
      const centerContentEl = document.getElementById('center-content');
      const backHint = document.getElementById('back-hint');
      const hintDrag = document.getElementById('hint-drag');
      const hintScroll = document.getElementById('hint-scroll');
      const hintType = document.getElementById('hint-type');
      const hintTypeStar = document.getElementById('hint-type-star');
      const moonStoryEl = document.getElementById('moon-story');
      const moonLineEl = document.getElementById('moon-line');
      const moonPromptEl = document.getElementById('moon-prompt');
      const moonInputValueEl = document.getElementById('moon-input-value');
      const countdownCaptionEl = document.getElementById('countdown-caption');
      const countdownNumberEl = document.getElementById('countdown-number');
      const sunIdleHintEl = document.getElementById('sun-idle-hint');
      const starTriggerEl = document.getElementById('star-trigger');
      const sunTriggerEl = document.getElementById('sun-trigger');
      const moonTriggerEl = document.getElementById('moon-trigger');
      const bedTriggerEl = document.getElementById('bed-trigger');
      const presetEl = document.getElementById('preset');
      const topTitleEl = document.querySelector('.top-title');

      // ====== 구체 머티리얼 ======
      const sphereBlackMaterial = new THREE.MeshStandardMaterial({
        color: 0x000000,
        roughness: 0.8,
        metalness: 0.2,
        emissive: 0x000000,
        emissiveIntensity: 0.0
      });

      // sun 모드: 어두운 노란빛
      const sphereSunMaterial = new THREE.MeshStandardMaterial({
        color: 0xffdd66,
        roughness: 0.5,
        metalness: 0.5,
        emissive: 0xffaa22,
        emissiveIntensity: 1.2
      });

      const sphereGeometry = new THREE.SphereGeometry(2, 64, 64);
      const sphere = new THREE.Mesh(sphereGeometry, sphereBlackMaterial);
      scene.add(sphere);
      // Texts will attach to this anchor so they follow sphere rotation but not scale
      const textAnchor = new THREE.Group();
      scene.add(textAnchor);
      
      // 모션 블러 효과를 위한 추가 구체들 (트레일 효과)
      const motionBlurSpheres = [];
      for (let i = 0; i < 3; i++) {
        const blurMaterial = new THREE.MeshStandardMaterial({
          color: 0x000000,
          roughness: 0.8,
          metalness: 0.2,
          transparent: true,
          opacity: 0.15 - i * 0.05
        });
        const blurSphere = new THREE.Mesh(sphereGeometry, blurMaterial);
        scene.add(blurSphere);
        motionBlurSpheres.push(blurSphere);
      }
      
      // 이전 구체 위치 저장
      let previousSphereRotations = [
        new THREE.Euler(),
        new THREE.Euler(),
        new THREE.Euler()
      ];

      // ---- sphere scale state (scroll로 조절) ----
      // [수정 1] 부드러운 스크롤을 위해 current와 target 분리
      let currentSphereScale = 6.0; // 시작은 더 크게 확대된 상태
      let targetSphereScale = 1.0;  // 천천히 기본 크기로 수렴
      let introActive = true;        // 도입 중 여부
      const INTRO_SHRINK_LERP = 0.06; // 도입 축소 속도 (조금 더 빠르게)
      const NORMAL_SHRINK_LERP = 0.1; // 일반 축소 속도
      const INTRO_ROT_PER_FRAME = 0.006; // 도입 중 더 강한 반시계 회전
      function applySphereScale() {
        // [수정 1] currentSphereScale 사용
        sphere.scale.set(currentSphereScale, currentSphereScale, currentSphereScale);
      }
      applySphereScale();

      // 현재 구 표면에서 살짝 바깥쪽까지의 반경 계산
      // base radius = 2 (sphereGeometry 생성 시 반지름)
      function getCurrentSurfaceRadius() {
        const baseR = 2;
        // [수정 1] currentSphereScale 사용
        return baseR * currentSphereScale + 0.2;
      }

      // 마우스 휠로 구체 크기 조절
      window.addEventListener('wheel', (e) => {
        if (interactionLocked) return;
        // 도입 종료 (사용자 인터랙션 발생)
        introActive = false;
        // 온보딩: 스크롤 조작 감지 시 Scroll 힌트 제거 후 Drag 힌트 표시
        if (mode === 'space') {
          if (hintScroll && hintScroll.classList.contains('visible')) {
            hideHint(hintScroll);
            scrollHintDismissed = true; // 다시는 표시하지 않음
            // 자동 숨김 타이머 클리어
            if (scrollHintAutoHideTimeoutId) {
              clearTimeout(scrollHintAutoHideTimeoutId);
              scrollHintAutoHideTimeoutId = null;
            }
            // 완전히 제거 (페이드아웃 이후)
            setTimeout(() => { if (scrollHintDismissed && hintScroll) hintScroll.style.display = 'none'; }, 800);
          } else {
            scrollHintDismissed = true;
          }
          setTimeout(() => {
            if (mode === 'space' && hintDrag && !dragHintDismissed) {
              showHint(hintDrag);
              // 10초 후 자동으로 페이드아웃
              dragHintAutoHideTimeoutId = setTimeout(() => {
                if (hintDrag && mode === 'space') {
                  hideHint(hintDrag);
                }
              }, 10000);
            }
          }, 250);
        }
        // scroll up (deltaY < 0) => 구 커짐
        // scroll down (deltaY > 0) => 구 작아짐
        const step = 0.05;
        if (e.deltaY < 0) {
          // [수정 1] targetSphereScale 변경
          targetSphereScale += step;
        } else {
          targetSphereScale -= step;
        }
        // 최소/최대 제한
        targetSphereScale = Math.min(3.0, Math.max(0.3, targetSphereScale));
        // Sun 모드: 확대/축소 입력 감지 → 유휴 힌트 즉시 숨김
        if (mode === 'sun') {
          lastSunZoomChange = performance.now();
          if (sunIdleHintVisible && sunIdleHintEl) {
            sunIdleHintEl.classList.remove('visible');
            sunIdleHintVisible = false;
          }
        }
        // [수정 1] applySphereScale() 호출 제거 (animate 루프에서 처리)
      }, { passive: true });

      // ====== 우주 별 (마인크래프트 픽셀스타) ======
      function createPixelStarTexture() {
        const size = 8;
        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d');

        ctx.clearRect(0, 0, size, size);
        ctx.fillStyle = 'white';
        // 중앙 4x4 하얀 픽셀 블록
        ctx.fillRect(2, 2, 4, 4);

        const texture = new THREE.CanvasTexture(canvas);
        texture.magFilter = THREE.NearestFilter;
        texture.minFilter = THREE.NearestFilter;
        texture.generateMipmaps = false;
        return texture;
      }
      const starTexture = createPixelStarTexture();

      // 큰 구 껍질 위에 별을 찍어서 배경 우주처럼
      function createStars(count, radiusShell, sizePx) {
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(count * 3);

        for (let i = 0; i < count; i++) {
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos((Math.random() * 2) - 1);

          const x = radiusShell * Math.sin(phi) * Math.cos(theta);
          const y = radiusShell * Math.sin(phi) * Math.sin(theta);
          const z = radiusShell * Math.cos(phi);

          positions[i * 3]     = x;
          positions[i * 3 + 1] = y;
          positions[i * 3 + 2] = z;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        const material = new THREE.PointsMaterial({
          map: starTexture,
          color: 0xffffff,
          size: sizePx,
          sizeAttenuation: false,
          transparent: true,
          opacity: 1.0,
          depthWrite: true,
          blending: THREE.NormalBlending
        });

        const pts = new THREE.Points(geometry, material);
        pts.userData = {
          baseSize: sizePx
        };
        return pts;
      }

      // 우주 돔 (반경 30) 및 구체 내부 별
      const starsGroup = new THREE.Group();
      const tinyStars = createStars(1400, 30, 1.0);
      const midStars  = createStars(400,  30, 1.5);
      const bigStars  = createStars(90,   30, 2.5);
      
      starsGroup.add(tinyStars, midStars, bigStars);
      scene.add(starsGroup);
      
      // 구체 내부 별들은 별도 그룹으로 관리 (구체 스케일에 따라 크기 조정)
      // 반경 2.0: 구체 표면과 동일한 위치에 배치
      const innerStarsGroup = new THREE.Group();
      const innerTinyStars = createStars(300, 2.0, 2.5);
      const innerMidStars  = createStars(100,  2.0, 3.5);
      const innerBigStars  = createStars(50,   2.0, 5.0);
      
      // 별들이 구체를 뚫고 보이도록 renderOrder 설정
      innerTinyStars.renderOrder = 999;
      innerMidStars.renderOrder = 999;
      innerBigStars.renderOrder = 999;
      
      // depthTest를 비활성화하여 항상 보이도록
      innerTinyStars.material.depthTest = false;
      innerMidStars.material.depthTest = false;
      innerBigStars.material.depthTest = false;
      
      // 투명도를 60%로 설정 (연하게)
      innerTinyStars.material.opacity = 0.6;
      innerMidStars.material.opacity = 0.6;
      innerBigStars.material.opacity = 0.6;
      
      innerStarsGroup.add(innerTinyStars, innerMidStars, innerBigStars);
      scene.add(innerStarsGroup);

      // ====== 상태 관리 ======
      // 모드: 'space' | 'sun' | 'bed' | 'terminal' | 'moon'
      let mode = 'space';
      const SUN_PRESET_FADE_SCALE = 1.7;
      const SUN_PRESET_SHOW_SCALE = 1.5; // 작아지면 다시 표시 (히스테리시스)
      let sunPresetHidden = false;
      let sunZoomAboveSince = null;
      let sunZoomSequenceTriggered = false;
      let lastSunZoomChange = performance.now();
      let sunIdleHintVisible = false;

      let currentInput = "";
      let font = null;
      let textMeshes = [];
      let currentTextMesh = null;

      let blackoutTriggered = false;
      let monolithSize = 0; // [수정 3] 모노리스 크기 변수
      
      // 커스텀 색상 모드
      let customColorMode = false;
      let customColorMaterial = null;

      // 문장 입력 시 구체를 잠깐 빠르게 회전시키는 스핀 효과
      let scatterSpinActive = false;
      let scatterSpinVelY = 0;
      let scatterSpinVelZ = 0;

      // Terminal 상태
      const API_ENDPOINT = "https://cim-back.vercel.app/chat/completions";
      const answerPrefix = "> ";
      let conversationHistory = []; // AI 대화 기록
      let awaitingAnswer = false;
      let userBuffer = "";
      let pendingChars = [];
      let typingTicker = null;
      let currentAnswerEl = null;
      let terminalAudio = null; // [수정 4] 오디오 객체 변수
      let starAudio = null; // Star에서 재생되는 오디오
      let questionIndex = 0; // 질문 인덱스 (0부터 시작)
      const fixedQuestions = [
        "...who was your first love",
        "...how much did you love",
        "...what object still reminds you of them"
      ]; // 고정 질문들

      // ====== Moon mode 상태 ======
      const moonLines = [
        "Look at the stars",
        "Don't look at me",
        "LOOK",
        "Make a wish upon the stars"
      ];
      let moonStep = 0;
      let moonAwaitingEnter = false;
      let moonAwaitingType = false;
      let moonInputBuffer = "";
      let moonAwaitingSecondEnter = false;
      let moonEnterPromptTimer = null;
      let moonLoadingInterval = null;
      let moonHistory = [];
      let moonConvTurns = 0;
      let moonAwaitingFinalDecision = false;
      let moonHasWished = false;
      let moonConversationActive = false;
      let moonTypePromptTimer = null;
      let moonAwaitingShrinkEnter = false;
      let moonCountdownInterval = null;
      let moonAwaitingWishSentence = false;
      let countdownCaptionInterval = null;
      
      // Interaction lock and dots shrink control
      let interactionLocked = false;
      let dotsShrinkActive = false;
      let dotsShrinkDone = false;
      
      // ====== 공용 AI 호출 (재시도/타임아웃) ======
      async function callAIWithRetries(messages, maxTokens, attemptTimeoutsMs = [14000, 20000, 28000, 36000]) {
        for (let i = 0; i < attemptTimeoutsMs.length; i++) {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), attemptTimeoutsMs[i]);
          try {
            const response = await fetch(API_ENDPOINT, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                messages,
                max_completion_tokens: maxTokens,
                model: "gpt-5-mini"
              }),
              signal: controller.signal
            });
            clearTimeout(timeoutId);
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            const data = await response.json();
            const content = (data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content) || "";
            if (content && content.trim()) return content.trim();
          } catch (e) {
            clearTimeout(timeoutId);
            console.warn('AI request attempt failed', i + 1, e);
            const backoff = Math.min(2000 * Math.pow(2, i), 8000);
            await new Promise(r => setTimeout(r, backoff));
          }
        }
        return null;
      }

      function clearMoonEnterPrompt() {
        if (moonEnterPromptTimer) {
          clearTimeout(moonEnterPromptTimer);
          moonEnterPromptTimer = null;
        }
      }
      function scheduleMoonEnterPrompt() {
        clearMoonEnterPrompt();
        moonEnterPromptTimer = setTimeout(() => setMoonPrompt('ENTER'), 3000);
      }
      function clearMoonTypePrompt() {
        if (moonTypePromptTimer) {
          clearTimeout(moonTypePromptTimer);
          moonTypePromptTimer = null;
        }
      }
      function scheduleMoonTypePrompt() {
        clearMoonTypePrompt();
        moonTypePromptTimer = setTimeout(() => {
          if (moonAwaitingType && (!moonInputBuffer || !moonInputBuffer.trim())) {
            setMoonPrompt('TYPE');
          }
        }, 5000);
      }
      function resetMoonInputBuffer(showType = false) {
        moonInputBuffer = "";
        if (showType) {
          setMoonPrompt('TYPE');
        } else {
          setMoonPrompt("");
        }
      }
      function startMoonLoading() {
        if (moonLoadingInterval) return;
        let dots = 0;
        moonLineEl.classList.remove('visible');
        setTimeout(() => {
          moonLineEl.textContent = '';
          moonLineEl.classList.add('visible');
        }, 120);
        moonLoadingInterval = setInterval(() => {
          dots = (dots + 1) % 4;
          moonLineEl.textContent = '.'.repeat(dots);
        }, 350);
      }
      function stopMoonLoading() {
        if (moonLoadingInterval) {
          clearInterval(moonLoadingInterval);
          moonLoadingInterval = null;
        }
      }

      function setMoonPrompt(text, big = true) {
        // Show prompts in the central typing indicator, not with underline
        typingIndicator.textContent = text || "";
        if (text && big) typingIndicator.classList.add('typing-big');
        else typingIndicator.classList.remove('typing-big');
        // Keep overlay prompt empty
        moonPromptEl.textContent = "";
      }

      function showMoonText(text) {
        // Fade out current text
        moonLineEl.classList.remove('visible');
        setTimeout(() => {
          moonLineEl.textContent = text || "";
          // Fade in next text
          requestAnimationFrame(() => {
            moonLineEl.classList.add('visible');
          });
        }, 700);
      }

      function startCountdownCaption() {
        if (!countdownCaptionEl) return;
        countdownCaptionEl.textContent = "Look beyond the universe.";
        countdownCaptionEl.classList.remove('visible');
        let visible = false;
        // toggle fade every 2s
        countdownCaptionInterval = setInterval(() => {
          visible = !visible;
          if (visible) countdownCaptionEl.classList.add('visible');
          else countdownCaptionEl.classList.remove('visible');
        }, 2000);
      }

      function stopCountdownCaption() {
        if (countdownCaptionInterval) {
          clearInterval(countdownCaptionInterval);
          countdownCaptionInterval = null;
        }
        if (countdownCaptionEl) {
          countdownCaptionEl.classList.remove('visible');
          countdownCaptionEl.textContent = "";
        }
      }

      function showCountdownNumber(value) {
        if (!countdownNumberEl) return;
        if (!countdownNumberEl.classList.contains('visible')) {
          countdownNumberEl.classList.add('visible');
        }
        countdownNumberEl.textContent = String(value);
      }

      function hideCountdownNumber() {
        if (!countdownNumberEl) return;
        countdownNumberEl.classList.remove('visible');
        countdownNumberEl.textContent = "";
      }

      function startMoonFinalCountdown(seconds = 5) {
        // Stop any prior countdown
        if (moonCountdownInterval) {
          clearInterval(moonCountdownInterval);
          moonCountdownInterval = null;
        }
        let remaining = seconds;
        // Start caption fade in/out during countdown
        startCountdownCaption();
        // Show initial number under the sphere (keep 'wish to the stars' on right)
        hideCountdownNumber();
        setTimeout(() => {
          showCountdownNumber(remaining);
        }, 120);
        // Clear prompts during countdown
        setMoonPrompt("");
        moonCountdownInterval = setInterval(() => {
          remaining -= 1;
          if (remaining <= 0) {
            clearInterval(moonCountdownInterval);
            moonCountdownInterval = null;
            // Stop caption when countdown ends
            stopCountdownCaption();
            hideCountdownNumber();
            // 부드럽게 극소화 (애니메이션로 수렴)
            targetSphereScale = 0.05;
            // Start dots shrinking to 0.5x, lock interaction after done
            dotsShrinkActive = true;
            dotsShrinkDone = false;
            // 입력 안내 표시 및 입력 모드 전환
            moonAwaitingWishSentence = true;
            moonAwaitingType = true;
            moonInputBuffer = "";
            setMoonPrompt('Write your wish in a sentence', false);
            return;
          }
          showCountdownNumber(remaining);
        }, 1000);
      }

      function startMoonSequence() {
        moonStep = 0;
        moonAwaitingType = false;
        moonAwaitingEnter = true;
        moonInputBuffer = "";
        moonInputValueEl.textContent = "";
        showMoonText(moonLines[moonStep]);
        setMoonPrompt('');
        scheduleMoonEnterPrompt();
      }

      async function moonGetShortReply(history) {
        return await callAIWithRetries(history, 60, [14000, 20000, 28000, 36000]);
      }

      async function handleMoonWish(wishText) {
        // 첫 응답
        const baseSystem = {
          role: 'system',
          content: "You are the stars hearing the user's wish. Reply in one short, concrete yet poetic phrase (≤6 words) that clearly references the main subject of the wish. Avoid ellipses. Avoid filler. No quotes."
        };
        const messages = [baseSystem, { role: 'user', content: wishText }];
        // 사용자가 친 문장을 구체 위에 단어별로 배치
        const wordsPlaced = wishText.split(/\s+/).filter(Boolean);
        const placeAngleStep = 0.08;
        const placeDownStep = 0.05;
        wordsPlaced.forEach((w, i) => createTextOnSphere(w, i, placeAngleStep, placeDownStep));
        moonHistory = [{ role: 'system', content: baseSystem.content }, { role: 'user', content: wishText }];
        startMoonLoading();
        // 성공할 때까지 추가 시도 (내부 재시도 포함하여 최대 몇 차례 더)
        let reply1 = await moonGetShortReply(messages);
        let extraTries1 = 2;
        while (!reply1 && extraTries1 > 0) {
          reply1 = await moonGetShortReply(messages);
          extraTries1--;
        }
        if (reply1) {
          stopMoonLoading();
          showMoonText(reply1);
          moonHistory.push({ role: 'assistant', content: reply1 });
          resetMoonInputBuffer(false);
          moonAwaitingSecondEnter = true;
          scheduleMoonEnterPrompt();
        } // 실패 시 로딩 유지 (하드코딩 문구 없음)
      }

      async function handleMoonSecondReply(wishText) {
        const baseSystem2 = {
          role: 'system',
          content: "You are the stars. Give a different, even shorter, concrete phrase (≤4 words) that still clearly connects to the user's wish. No ellipses, no quotes."
        };
        const messages2 = [baseSystem2, { role: 'user', content: wishText }];
        startMoonLoading();
        let reply2 = await moonGetShortReply(messages2);
        let extraTries2 = 2;
        while (!reply2 && extraTries2 > 0) {
          reply2 = await moonGetShortReply(messages2);
          extraTries2--;
        }
        if (reply2) {
          stopMoonLoading();
          showMoonText(reply2);
          moonHistory.push({ role: 'assistant', content: reply2 });
        }
        // 짧은 지연 후 본 대화 시작 (사용자 입력 3회)
        setTimeout(() => {
          clearMoonEnterPrompt();
          moonConvTurns = 0;
          moonConversationActive = true;
          moonAwaitingType = true;
          resetMoonInputBuffer(true);
          scheduleMoonTypePrompt();
        }, 500);
      }

      async function moonGetConversationalReply(history) {
        return await callAIWithRetries(history, 120, [15000, 22000, 30000, 36000]);
      }

      function askMoonFinalQuestion() {
        showMoonText("...you want to see the light?");
        moonAwaitingFinalDecision = true;
        moonAwaitingType = true;
        resetMoonInputBuffer(true);
        scheduleMoonTypePrompt();
      }

      function isPositiveResponse(text) {
        const t = (text || '').toLowerCase();
        const positives = [ 'yes', 'y', 'ok', 'okay', 'sure', 'do', 'want', 'please', '네', '응', '좋아', '그래', '응응' ];
        const negatives = [ 'no', 'n', "don't", 'not', "nope", '아니', '싫어', '아니요' ];
        if (negatives.some(w => t.includes(w))) return false;
        if (positives.some(w => t.includes(w))) return true;
        // 기본은 부정 아님 => 긍정으로 간주해도 됨 (연출상)
        return true;
      }

      function enterMoonMode() {
        mode = 'moon';
        // Clear other mode classes to avoid overlap
        document.body.classList.remove('sun-glow');
        document.body.classList.remove('dark');
        if (presetEl) { presetEl.style.opacity = '0'; presetEl.style.pointerEvents = 'none'; }

        // Hide unrelated overlays - 모든 모드 오버레이 정리
        bedWrapper.style.display = 'none';
        monolith.style.display = 'none';
        blackoutTriggered = false;
        blackoutEl.classList.remove('active');
        terminalEl.classList.remove('active');
        terminalExitHint.classList.remove('active');
        terminalContentEl.innerHTML = "";
        centerContentEl.classList.remove('active');
        centerContentEl.innerHTML = "";
        backHint.classList.remove('active');
        renderer.domElement.style.opacity = '1';

        // Sun 모드 관련 정리
        if (sunIdleHintEl) sunIdleHintEl.classList.remove('visible');
        sunIdleHintVisible = false;
        lastSunZoomChange = performance.now();

        // Moon UI
        moonStoryEl.classList.add('active');
        startMoonSequence();

        // preset underline: Star underlined only (Star 모드이므로)
        if (starTriggerEl) starTriggerEl.classList.add('primary');
        if (sunTriggerEl) sunTriggerEl.classList.remove('primary');
        if (moonTriggerEl) moonTriggerEl.classList.remove('primary');
        if (bedTriggerEl) bedTriggerEl.classList.remove('primary');

        // Star 힌트 숨김
        if (hintTypeStar) hideHint(hintTypeStar);
        if (starTypeHintTimeoutId) { clearTimeout(starTypeHintTimeoutId); starTypeHintTimeoutId = null; }
        if (starTypeHintAutoHideTimeoutId) { clearTimeout(starTypeHintAutoHideTimeoutId); starTypeHintAutoHideTimeoutId = null; }

        // stop unrelated visuals/audio
        stopCountdownCaption();
        hideCountdownNumber();
        if (starAudio) {
          starAudio.pause();
          starAudio.currentTime = 0;
          starAudio = null;
        }
        if (terminalAudio) {
          terminalAudio.pause();
          terminalAudio.currentTime = 0;
          terminalAudio = null;
        }
      }

      // ====== 폰트 로드 (구 위 텍스트용) ======
      const fontLoader = new FontLoader();
      // 먼저 나눔명조(typeface.json)를 시도하고, 실패 시 기존 Droid Serif로 폴백
      const nanumTypefaceUrl = './fonts/NanumMyeongjo_Regular.typeface.json';
      fontLoader.load(
        nanumTypefaceUrl,
        (loadedFont) => {
          font = loadedFont;
        },
        undefined,
        () => {
          // 폴백: 기존 드로이드 세리프
          fontLoader.load(
            'https://threejs.org/examples/fonts/droid/droid_serif_regular.typeface.json',
            (fallbackFont) => {
              font = fallbackFont;
            }
          );
        }
      );

      // 구 표면 근처에 단어를 "찍는" 함수
      // 중요: 텍스트 geometry의 size는 항상 고정(0.15)
      //       sphereScale과 상관없이 일정한 실제 크기로 생성됨
      function createTextOnSphere(text, offsetIndex = 0, offsetAngleStep = 0, offsetDownStep = 0) {
        if (!font) return;

        const textGeometry = new TextGeometry(text, {
          font: font,
          size: 0.15,      // ← 항상 같은 크기
          height: 0.02,
        });

        textGeometry.center();

        const textMaterial = new THREE.MeshStandardMaterial({
          color: 0xffffff,
          emissive: (mode === 'sun') ? 0xffffff : 0x000000,
          emissiveIntensity: (mode === 'sun') ? 1.2 : 0
        });

        const textMesh = new THREE.Mesh(textGeometry, textMaterial);

        // 현재 구의 (스케일 반영된) 반지름 + 약간 튀어나옴
        const radius = getCurrentSurfaceRadius();

        // 카메라 방향 벡터 구해서 그 방향에 찍기
        const cameraDirection = new THREE.Vector3();
        camera.getWorldDirection(cameraDirection);
        cameraDirection.negate(); // 카메라 -> 구 중심 방향

        // [수정 2] 정규화된 방향 벡터 저장
        const normalizedDirection = cameraDirection.clone().normalize();
        // 동일 입력(한 문장)의 각 단어가 약간씩 오른쪽으로 치우치도록 위치 각도 보정
        let placeDirection = normalizedDirection.clone();
        if (offsetAngleStep && offsetIndex > 0) {
          placeDirection.applyAxisAngle(camera.up, offsetIndex * offsetAngleStep);
        }
        if (offsetDownStep && offsetIndex > 0) {
          // 카메라의 오른쪽 축을 기준으로 아래쪽으로 살짝 기울이기 (우하향)
          const camForward = cameraDirection.clone().normalize();
          const camRight = new THREE.Vector3().crossVectors(camForward, camera.up).normalize();
          placeDirection.applyAxisAngle(camRight, -offsetDownStep * offsetIndex);
        }
        // 앵커의 회전을 따르도록 로컬 방향으로 저장
        const invAnchorQ = textAnchor.getWorldQuaternion(new THREE.Quaternion()).invert();
        const localDirection = placeDirection.clone().applyQuaternion(invAnchorQ).normalize();
        
        textMesh.position.copy(localDirection.clone().multiplyScalar(radius));
        
        // 바깥쪽을 바라보도록 (월드 좌표 기준)
        const outwardWorld = textAnchor.localToWorld(localDirection.clone().multiplyScalar(radius * 2));
        textMesh.lookAt(outwardWorld);

        textMesh.userData = {
          normalizedDirection: placeDirection.clone(), // world ref (legacy)
          localDirection: localDirection.clone(), // anchor-local direction
          targetPosition: textMesh.position.clone(),
          isFloating: false,
          floatSpeed: 0,
          rotationSpeed: 0
        };
        
        textAnchor.add(textMesh);
        textMeshes.push(textMesh);

        // sun 모드라면 새로 생긴 글자도 바로 우주로 '떠다니는' 상태로 전환
        if (mode === 'sun') {
          makeTextFloat(textMesh);
        }

        return textMesh;
      }

      function clearAllTextMeshes() {
        if (!textMeshes || textMeshes.length === 0) return;
        textMeshes.forEach(mesh => {
          if (mesh.parent) {
            mesh.parent.remove(mesh);
          } else {
            scene.remove(mesh);
          }
          if (mesh.geometry) mesh.geometry.dispose();
          if (mesh.material) mesh.material.dispose();
        });
        textMeshes = [];
      }

      function createRingFromSentence(sentence) {
        if (!font) return;
        const words = (sentence || "").split(/\s+/).filter(Boolean);
        if (words.length === 0) return;

        // 기존 단어 제거
        clearAllTextMeshes();

        const total = Math.max(80, Math.min(220, words.length * 50));
        const ringOffset = 0.8; // 표면에서 띄우는 양

        for (let i = 0; i < total; i++) {
          const word = words[i % words.length];
          const angle = (i / total) * Math.PI * 2;

          const textGeometry = new TextGeometry(word, {
            font: font,
            size: 0.15,
            height: 0.02,
          });
          textGeometry.center();

          const textMaterial = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            emissive: (mode === 'sun') ? 0xffffff : 0x000000,
            emissiveIntensity: (mode === 'sun') ? 1.2 : 0
          });

          const textMesh = new THREE.Mesh(textGeometry, textMaterial);
          textMesh.userData = {
            isOrbiting: true,
            orbitSpeed: 0,
            orbitAngle: angle,
            orbitRadiusOffset: ringOffset,
            localDirection: new THREE.Vector3(0, 0, 1),
            selfRotateSpeed: 0,
            targetPosition: new THREE.Vector3(),
            normalizedDirection: new THREE.Vector3(0, 0, 1)
          };

          // 초기 배치 (애니메이션 루프에서 계속 유지)
          const newRadius = getCurrentSurfaceRadius() + ringOffset;
          const yAxis = new THREE.Vector3(0, 1, 0);
          const rotated = textMesh.userData.localDirection.clone().applyAxisAngle(yAxis, angle).normalize();
          textMesh.position.copy(rotated.clone().multiplyScalar(newRadius));
          const outwardWorld = textAnchor.localToWorld(rotated.clone().multiplyScalar(newRadius * 2));
          textMesh.lookAt(outwardWorld);

          textAnchor.add(textMesh);
          textMeshes.push(textMesh);
        }
      }

      // sun 모드: 텍스트를 우주로 밀어내는 애니메이션 파라미터 부여
      function makeTextFloat(textMesh) {
        textMesh.material.emissive.setHex(0xffffff);
        textMesh.material.emissiveIntensity = 1.5;

        // 앵커에서 분리하여 월드 기준으로 떠다니도록 처리
        // 현재 월드 위치/회전 보존
        const worldPos = new THREE.Vector3();
        textMesh.getWorldPosition(worldPos);
        const worldQuat = new THREE.Quaternion();
        textMesh.getWorldQuaternion(worldQuat);
        if (textMesh.parent) textMesh.parent.remove(textMesh);
        scene.add(textMesh);
        textMesh.position.copy(worldPos);
        textMesh.setRotationFromQuaternion(worldQuat);

        const floatDirection = textMesh.position.clone().normalize();
        const floatDistance = 3 + Math.random() * 2;
        textMesh.userData.targetPosition = floatDirection.multiplyScalar(floatDistance);
        textMesh.userData.isFloating = true;
        textMesh.userData.floatSpeed = 0.015 + Math.random() * 0.015;
        textMesh.userData.rotationSpeed = (Math.random() - 0.5) * 0.03;
      }

      // sun 모드: 텍스트를 구 주위를 도는 위성처럼
      function makeTextOrbit(textMesh) {
        textMesh.material.emissive.setHex(0xffffff);
        textMesh.material.emissiveIntensity = 1.5;

        // 앵커에 부착 보장
        const worldPos = new THREE.Vector3();
        textMesh.getWorldPosition(worldPos);
        const worldQuat = new THREE.Quaternion();
        textMesh.getWorldQuaternion(worldQuat);
        if (textMesh.parent !== textAnchor) {
          if (textMesh.parent) textMesh.parent.remove(textMesh);
          textAnchor.add(textMesh);
          // 재배치: 앵커 로컬 방향 업데이트
          const invAnchorQ = textAnchor.getWorldQuaternion(new THREE.Quaternion()).invert();
          const dirFromWorld = worldPos.clone().normalize().applyQuaternion(invAnchorQ).normalize();
          textMesh.userData.localDirection = dirFromWorld;
        }

        // 오빗 파라미터
        textMesh.userData.isOrbiting = true;
        textMesh.userData.isFloating = false;
        textMesh.userData.orbitAngle = Math.random() * Math.PI * 2;
        textMesh.userData.orbitSpeed = 0.004 + Math.random() * 0.006; // 조금 더 역동적
        textMesh.userData.orbitRadiusOffset = 0.5 + Math.random() * 0.7; // 표면에서 살짝 띄움
        textMesh.userData.selfRotateSpeed = (Math.random() - 0.5) * 0.06;
      }

      // ====== 색상 맵 ======
      const colorMap = {
        'red': 0xff0000,
        'blue': 0x0000ff,
        'green': 0x00ff00,
        'yellow': 0xffff00,
        'purple': 0x800080,
        'pink': 0xffc0cb,
        'orange': 0xffa500,
        'cyan': 0x00ffff,
        'magenta': 0xff00ff,
        'white': 0xffffff,
        'grey': 0x808080,
        'gray': 0x808080,
        'brown': 0x8b4513,
        'lime': 0x00ff00,
        'navy': 0x000080,
        'teal': 0x008080,
        'violet': 0xee82ee,
        'gold': 0xffd700,
        'silver': 0xc0c0c0
      };
      
      function setCustomSphereColor(colorName) {
        const colorHex = colorMap[colorName.toLowerCase()];
        if (colorHex === undefined) return false;
        
        customColorMode = true;
        customColorMaterial = new THREE.MeshStandardMaterial({
          color: colorHex,
          roughness: 0.6,
          metalness: 0.4,
          emissive: colorHex,
          emissiveIntensity: 0.3
        });
        
        sphere.material = customColorMaterial;
        
        // 모션 블러 구체들도 색상 변경
        motionBlurSpheres.forEach((blurSphere, i) => {
          blurSphere.material.color.setHex(colorHex);
          blurSphere.material.emissive.setHex(colorHex);
          blurSphere.material.emissiveIntensity = 0.2 - i * 0.05;
        });
        
        return true;
      }

      // ====== 모드 전환 ======

      function resetToNormal() {
        mode = 'space';
        document.body.classList.remove('dark');
        document.body.classList.remove('sun-glow');

        renderer.domElement.style.opacity = '1';
        // unlock interactions
        interactionLocked = false;
        controls.enabled = true;

        // bed stuff off
        bedWrapper.style.display = 'none';
        monolith.style.display = 'none';
        // [수정 3] 모노리스 리셋
        monolithSize = 0;
        monolith.style.width = '0px';
        monolith.style.height = '0px';

        // blackout/terminal reset
        blackoutTriggered = false;
        blackoutEl.classList.remove('active');
        terminalEl.classList.remove('active');
        terminalExitHint.classList.remove('active');
        terminalContentEl.innerHTML = "";
        conversationHistory = [];
        questionIndex = 0;
        postAsciiQuestionCount = 0;
        awaitingAnswer = false;
        userBuffer = "";
        pendingChars = [];
        if (typingTicker) {
          clearInterval(typingTicker);
          typingTicker = null;
        }
        // [수정 4] 오디오 정지
        if (terminalAudio) {
          terminalAudio.pause();
          terminalAudio.currentTime = 0;
        }
        
        // center-content reset
        centerContentEl.classList.remove('active');
        centerContentEl.innerHTML = "";
        backHint.classList.remove('active');
        // Moon reset
        moonStoryEl.classList.remove('active');
        moonLineEl.textContent = "";
        moonLineEl.classList.remove('visible');
        setMoonPrompt("");
        moonInputValueEl.textContent = "";
        clearMoonEnterPrompt();
        stopMoonLoading();
        clearMoonTypePrompt();
        stopCountdownCaption();
        hideCountdownNumber();
        moonHistory = [];
        moonConvTurns = 0;
        moonAwaitingFinalDecision = false;
        moonHasWished = false;
        moonConversationActive = false;
        
        // Star 오디오 정지
        if (starAudio) {
          starAudio.pause();
          starAudio.currentTime = 0;
          starAudio = null;
        }

        // sphere back to black core (크기 유지, scale은 그대로 두고 머티리얼만 복귀)
        sphere.material = sphereBlackMaterial;
        customColorMode = false;
        customColorMaterial = null;
        
        // 모션 블러 구체들도 리셋
        motionBlurSpheres.forEach(blurSphere => {
          blurSphere.material.color.setHex(0x000000);
          blurSphere.scale.copy(sphere.scale);
        });

        // 별 초기화
        tinyStars.material.size = tinyStars.userData.baseSize;
        midStars.material.size  = midStars.userData.baseSize;
        bigStars.material.size  = bigStars.userData.baseSize;
        innerTinyStars.material.size = innerTinyStars.userData.baseSize;
        innerMidStars.material.size  = innerMidStars.userData.baseSize;
        innerBigStars.material.size  = innerBigStars.userData.baseSize;
        tinyStars.material.opacity = 1.0;
        midStars.material.opacity  = 1.0;
        bigStars.material.opacity  = 1.0;
        innerTinyStars.material.opacity = 0.6;
        innerMidStars.material.opacity  = 0.6;
        innerBigStars.material.opacity  = 0.6;
        
        // depthTest 복원
        innerTinyStars.material.depthTest = false;
        innerMidStars.material.depthTest = false;
        innerBigStars.material.depthTest = false;

        // 구 위 텍스트들 제거
        textMeshes.forEach(mesh => {
          if (mesh.parent) {
            mesh.parent.remove(mesh);
          } else {
            scene.remove(mesh);
          }
          mesh.geometry.dispose();
          mesh.material.dispose();
        });
        textMeshes = [];
        currentTextMesh = null;

        currentInput = "";
        typingIndicator.textContent = "";

        // 온보딩 힌트 정리
        if (hintDrag) hintDrag.classList.remove('visible');
        if (hintScroll) hintScroll.classList.remove('visible');
        
        // preset underline reset: 초기 상태에서는 밑줄 없음
        if (starTriggerEl) starTriggerEl.classList.remove('primary');
        if (sunTriggerEl) sunTriggerEl.classList.remove('primary');
        if (moonTriggerEl) moonTriggerEl.classList.remove('primary');
        if (bedTriggerEl) bedTriggerEl.classList.remove('primary');
      }

      function enterSunMode() {
        mode = 'sun';
        // clear any previous mode visuals
        document.body.classList.remove('sun-glow');
        document.body.classList.remove('dark');
        document.body.classList.add('dark');
        document.body.classList.add('sun-glow');
        sunPresetHidden = false;
        sunZoomAboveSince = null;
        sunZoomSequenceTriggered = false;
        if (presetEl) { presetEl.style.opacity = '1'; presetEl.style.pointerEvents = 'auto'; }

        renderer.domElement.style.opacity = '1';
        // re-enable interactions in Sun mode
        interactionLocked = false;
        controls.enabled = true;

        // bed, terminal, blackout 끄기
        bedWrapper.style.display = 'none';
        monolith.style.display = 'none';
        blackoutEl.classList.remove('active');
        terminalEl.classList.remove('active');
        terminalExitHint.classList.remove('active');
        terminalContentEl.innerHTML = "";
        // moon 오버레이 종료 - Moon GIF와 Star 이벤트 완전 정리
        moonStoryEl.classList.remove('active');
        moonLineEl.textContent = "";
        moonLineEl.classList.remove('visible');
        setMoonPrompt("");
        centerContentEl.classList.remove('active');
        centerContentEl.innerHTML = "";
        backHint.classList.remove('active');

        // 구체를 노란 태양으로 (scale 유지)
        sphere.material = sphereSunMaterial;

        // 별 강조
        [tinyStars, midStars, bigStars].forEach(points => {
          points.material.size = points.userData.baseSize * 1.2;
          points.material.opacity = 1.0;
        });
        
        // 내부 별들도 강조 (투명도는 0.7 정도로)
        [innerTinyStars, innerMidStars, innerBigStars].forEach(points => {
          points.material.size = points.userData.baseSize * 1.2;
          points.material.opacity = 0.7;
        });

        // 이미 있는 텍스트는 오빗(위성) 모션 부여
        textMeshes.forEach(mesh => {
          makeTextOrbit(mesh);
        });

        // 온보딩 힌트 숨김
        if (hintDrag) hintDrag.classList.remove('visible');
        if (hintScroll) hintScroll.classList.remove('visible');
        
        // preset underline: Sun underlined, Star not
        if (starTriggerEl) starTriggerEl.classList.remove('primary');
        if (sunTriggerEl) sunTriggerEl.classList.add('primary');
        if (moonTriggerEl) moonTriggerEl.classList.remove('primary');
        if (bedTriggerEl) bedTriggerEl.classList.remove('primary');

        // stop any moon countdown visuals or external audio
        stopCountdownCaption();
        hideCountdownNumber();
        if (starAudio) {
          starAudio.pause();
          starAudio.currentTime = 0;
          starAudio = null;
        }
        // Sun idle hint 초기화
        lastSunZoomChange = performance.now();
        if (sunIdleHintEl) sunIdleHintEl.classList.remove('visible');
        sunIdleHintVisible = false;

        // Star 힌트 숨김 (Sun 진입 시 비활성화)
        if (hintTypeStar) hideHint(hintTypeStar);
        if (starTypeHintTimeoutId) { clearTimeout(starTypeHintTimeoutId); starTypeHintTimeoutId = null; }
        if (starTypeHintAutoHideTimeoutId) { clearTimeout(starTypeHintAutoHideTimeoutId); starTypeHintAutoHideTimeoutId = null; }
      }

      function enterBedMode() {
        mode = 'bed';
        document.body.classList.remove('sun-glow');
        document.body.classList.remove('dark');
        if (presetEl) { presetEl.style.opacity = '1'; presetEl.style.pointerEvents = 'auto'; }

        // 3D 안 보이게
        renderer.domElement.style.opacity = '0';

        // 침대 크게 보여주기
        bedWrapper.style.display = 'block';

        // monolith on
        monolith.style.display = 'block';
        // [수정 3] 모노리스 리셋
        monolithSize = 0;
        monolith.style.width = '0px';
        monolith.style.height = '0px';

        // blackout/terminal off
        blackoutTriggered = false;
        blackoutEl.classList.remove('active');
        terminalEl.classList.remove('active');
        terminalExitHint.classList.remove('active');
        terminalContentEl.innerHTML = "";

        // Moon GIF와 Star 이벤트 완전 정리
        moonStoryEl.classList.remove('active');
        moonLineEl.textContent = "";
        moonLineEl.classList.remove('visible');
        setMoonPrompt("");
        clearMoonEnterPrompt();
        stopMoonLoading();
        centerContentEl.classList.remove('active');
        centerContentEl.innerHTML = "";
        backHint.classList.remove('active');

        // 온보딩 힌트 숨김
        if (hintDrag) hintDrag.classList.remove('visible');
        if (hintScroll) hintScroll.classList.remove('visible');

        // preset underline: Bed underlined only
        if (starTriggerEl) starTriggerEl.classList.remove('primary');
        if (sunTriggerEl) sunTriggerEl.classList.remove('primary');
        if (moonTriggerEl) moonTriggerEl.classList.remove('primary');
        if (bedTriggerEl) bedTriggerEl.classList.add('primary');

        // stop other mode visuals/audio
        stopCountdownCaption();
        hideCountdownNumber();
        if (starAudio) {
          starAudio.pause();
          starAudio.currentTime = 0;
          starAudio = null;
        }
        if (terminalAudio) {
          terminalAudio.pause();
          terminalAudio.currentTime = 0;
          terminalAudio = null;
        }
        // Sun 모드 관련 정리
        if (sunIdleHintEl) sunIdleHintEl.classList.remove('visible');
        sunIdleHintVisible = false;
      }

      // monolith가 침대 높이를 넘으면 블랙아웃 전환
      function checkMonolithOverflow(currentHeightPx) {
        // [수정 3] 침대 높이 대신 뷰포트 높이의 80% 기준으로 변경
        // (모노리스와 침대가 둘 다 viewport 중앙 기준이므로)
        const thresholdH = window.innerHeight * 0.8;
        if (currentHeightPx >= thresholdH && !blackoutTriggered) {
          triggerBlackout();
        }
      }

      function triggerBlackout() {
        if (blackoutTriggered) return;
        blackoutTriggered = true;

        blackoutEl.classList.add('active');

        blackoutEl.addEventListener('transitionend', () => {
          startTerminalMode();
        }, { once: true });
      }

      // Moon 간단 연출(오디오+GIF)을 위한 헬퍼
      function showMoonSimple() {
        renderer.domElement.style.opacity = '0';
        centerContentEl.innerHTML = "";
        // 오디오 재생
        starAudio = new Audio("https://actions.google.com/sounds/v1/human_voices/babies_coo.ogg");
        starAudio.play().catch(e => console.warn("Audio play failed:", e));
        // 이미지 표시
        const img = document.createElement("img");
        img.setAttribute("src", "https://media4.giphy.com/media/v1.Y2lkPTc5MGI3NjExZHo5dTI0cHM0ZG1tM3N5ZWR6bHM2MTYwYm1pNWt6dDgzd25yajgybyZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/hXTsVGndgr1oMC2F9t/giphy.gif");
        img.setAttribute("alt", "sleep gif");
        centerContentEl.appendChild(img);
        centerContentEl.classList.add("active");
        backHint.classList.add("active");
      }

      // Moon (GIF) 모드로 안전 전환
      function enterMoonSimpleMode() {
        mode = 'moon';
        document.body.classList.remove('sun-glow');
        document.body.classList.remove('dark');

        // 모든 오버레이/상태 정리 - 모든 모드 오버레이 완전 정리
        bedWrapper.style.display = 'none';
        monolith.style.display = 'none';
        blackoutTriggered = false;
        blackoutEl.classList.remove('active');
        terminalEl.classList.remove('active');
        terminalExitHint.classList.remove('active');
        terminalContentEl.innerHTML = "";
        if (terminalAudio) {
          terminalAudio.pause();
          terminalAudio.currentTime = 0;
          terminalAudio = null;
        }
        // Moon 스토리 UI 비활성화(간단 GIF만 사용)
        moonStoryEl.classList.remove('active');
        setMoonPrompt("");
        clearMoonEnterPrompt();
        stopMoonLoading();
        stopCountdownCaption();
        hideCountdownNumber();

        // Sun 모드 관련 정리
        if (sunIdleHintEl) sunIdleHintEl.classList.remove('visible');
        sunIdleHintVisible = false;
        lastSunZoomChange = performance.now();

        // preset underline
        if (starTriggerEl) starTriggerEl.classList.remove('primary');
        if (sunTriggerEl) sunTriggerEl.classList.remove('primary');
        if (bedTriggerEl) bedTriggerEl.classList.remove('primary');
        if (moonTriggerEl) moonTriggerEl.classList.add('primary');

        // 간단 Moon 연출 표시
        showMoonSimple();
      }

      // ====== 해커 단말 모드 ======
      function startTerminalMode() {
        mode = 'terminal';
        document.body.classList.add('dark');
        document.body.classList.remove('sun-glow');

        bedWrapper.style.display = 'none';
        monolith.style.display = 'none';
        renderer.domElement.style.opacity = '0';

        // Moon GIF와 Star 이벤트 완전 정리
        moonStoryEl.classList.remove('active');
        moonLineEl.textContent = "";
        moonLineEl.classList.remove('visible');
        setMoonPrompt("");
        clearMoonEnterPrompt();
        stopMoonLoading();
        centerContentEl.classList.remove('active');
        centerContentEl.innerHTML = "";
        backHint.classList.remove('active');

        terminalEl.classList.add('active');
        terminalExitHint.classList.add('active');
        terminalContentEl.innerHTML = "";

        conversationHistory = [];
        questionIndex = 0;
        postAsciiQuestionCount = 0;
        awaitingAnswer = false;
        userBuffer = "";
        pendingChars = [];
        if (typingTicker) {
          clearInterval(typingTicker);
          typingTicker = null;
        }

        // [수정 4] 오디오 재생 로직 추가
        if (!terminalAudio) {
          terminalAudio = new Audio('./public/goldeneye.mp3');
          terminalAudio.volume = 1.0;
          
          // 오디오 메타데이터 로드 시 페이드 아웃 설정
          terminalAudio.addEventListener('loadedmetadata', () => {
            const duration = terminalAudio.duration;
            const fadeStartTime = duration - 3; // 종료 3초 전부터 페이드 아웃
            
            terminalAudio.addEventListener('timeupdate', () => {
              if (terminalAudio.currentTime >= fadeStartTime) {
                const timeLeft = duration - terminalAudio.currentTime;
                terminalAudio.volume = Math.max(0, timeLeft / 3); // 3초 동안 페이드 아웃
              }
            });
          });
        }
        terminalAudio.currentTime = 0;
        terminalAudio.volume = 1.0;
        terminalAudio.play().catch(e => console.warn("Audio play failed:", e));

        // 오디오 재생과 동시에 질문 시작
        askNextQuestion();

        // 온보딩 힌트 숨김
        if (hintDrag) hintDrag.classList.remove('visible');
        if (hintScroll) hintScroll.classList.remove('visible');
      }

      function scrollTerminalToBottom() {
        terminalEl.scrollTop = terminalEl.scrollHeight;
      }

      function addLine(initialText = "") {
        const lineEl = document.createElement('div');
        lineEl.className = 'term-line';
        lineEl.textContent = initialText;
        terminalContentEl.appendChild(lineEl);
        scrollTerminalToBottom();
        return lineEl;
      }

      // 시스템 질문을 한 글자씩 찍는 효과
      function typeSystemLine(text, done) {
        const lineEl = addLine("");
        let i = 0;
        const iv = setInterval(() => {
          lineEl.textContent += text.charAt(i);
          i++;
          scrollTerminalToBottom();
          if (i >= text.length) {
            clearInterval(iv);
            setTimeout(() => {
              done();
            }, 150);
          }
        }, 40);
      }

      function updateAnswerDisplay() {
        if (!currentAnswerEl) return;
        currentAnswerEl.innerHTML = "";

        const textSpan = document.createElement('span');
        textSpan.textContent = answerPrefix + userBuffer;
        currentAnswerEl.appendChild(textSpan);

        const cursorSpan = document.createElement('span');
        cursorSpan.className = 'cursor';
        currentAnswerEl.appendChild(cursorSpan);

        scrollTerminalToBottom();
      }

      function startAnswerCapture() {
        awaitingAnswer = true;
        userBuffer = "";
        pendingChars = [];
        if (typingTicker) {
          clearInterval(typingTicker);
          typingTicker = null;
        }
        currentAnswerEl = addLine("");
        updateAnswerDisplay();
      }

      async function askNextQuestion() {
        // 5개 질문을 모두 마쳤으면 아스키 아트 생성
        if (questionIndex >= 5) {
          await generateAsciiArt();
          return;
        }

        let questionText = "";
        
        // 처음 3개는 고정 질문
        if (questionIndex < fixedQuestions.length) {
          questionText = fixedQuestions[questionIndex];
        } else {
          // 4-5번째 질문은 AI 생성
          try {
            conversationHistory.push({
              role: "system",
              content: "You are a quiet voice drawing out tender memories of the user's first love. Ask one short, straightforward question (starting with '...') that nudges toward a specific element or moment to render later: a shared moment (a glance, a sound, a brief scene), their joined hands, or a keepsake/object. Avoid food topics. Keep it in English, gentle, and answerable in a few words. Examples: '...the exact moment you realized you loved them?', '...how did their hand feel in yours?', '...what object still carries their scent?', '...what were they looking at?', '...what color was it?', '...where did you keep it?'"
            });
            
            // AI 응답 대기 중 '...' 애니메이션
            const waitingLineEl = addLine("");
            let dotCount = 0;
            const dotInterval = setInterval(() => {
              dotCount = (dotCount + 1) % 4;
              waitingLineEl.textContent = '.'.repeat(dotCount);
            }, 500);
            
            const response = await fetch(API_ENDPOINT, {
              method: "POST",
              headers: {
                "Content-Type": "application/json"
              },
              body: JSON.stringify({
                messages: conversationHistory,
                max_completion_tokens: 1000,
                model: "gpt-5-mini"
              })
            });
            
            const data = await response.json();
            questionText = data.choices[0].message.content.trim();
            
            // AI 응답을 대화 기록에 추가
            conversationHistory.push({
              role: "assistant",
              content: questionText
            });
            
            // 대기 애니메이션 제거
            clearInterval(dotInterval);
            waitingLineEl.remove();
          } catch (error) {
            console.error("AI request failed:", error);
            clearInterval(dotInterval);
            waitingLineEl.remove();
            questionText = "...what do you seek?";
          }
        }
        
        typeSystemLine(questionText, () => {
          startAnswerCapture();
        });
      }

      // 아스키 아트 생성 함수
      async function generateAsciiArt() {
        awaitingAnswer = false;
        
        // 빈 줄 추가
        addLine("");
        
        // AI 응답 대기 중 '...' 애니메이션
        const waitingLineEl = addLine("");
        let dotCount = 0;
        const dotInterval = setInterval(() => {
          dotCount = (dotCount + 1) % 4;
          waitingLineEl.textContent = '.'.repeat(dotCount);
        }, 500);
        
        try {
          conversationHistory.push({
            role: "system",
            content: "Based on the entire conversation, especially the element tied to their first love (their joined hands, a keepsake/object, or a small shared moment/scene), create a HIGHLY ACCURATE and detailed ASCII art that PRECISELY represents that single element or moment. CRITICAL REQUIREMENTS:\n\n1. ACCURACY FIRST: Capture the subject's EXACT shapes, proportions, textures, and distinctive features, so it is instantly recognizable.\n2. SIZE: 30-40 lines tall, 70-90 characters wide for maximum detail\n3. CHARACTER VARIETY: Use rich variety - spaces, dots (.:·∙), lines (-=_~¯‾), curves (()[]{}<>), slashes (/\\|║╱╲), corners (┌┐└┘╭╮╰╯├┤┬┴┼), blocks (█▓▒░■□▪▫), special (#@&$%*+×!), circles (Oo0○●◯◉)\n4. SHADING GRADIENT (critical for realism):\n   - Brightest: '  ' (spaces)\n   - Very light: '·.∙:,'\n   - Light: '-~=_'\n   - Medium-light: '+*xo'\n   - Medium: '#@&%'\n   - Dark: '▒▓█'\n   - Use smooth gradients between light and shadow\n5. STRUCTURE:\n   - Use clear, strong outlines with |/\\-_\n   - Add depth with proper perspective\n   - Include ALL distinctive features (e.g., interlaced fingers for hands; labels, laces, or wear-marks for keepsakes; subtle gaze direction, posture, or minimal background cues for a small moment)\n   - Pay careful attention to proportions\n6. CATEGORY NOTES (apply only if relevant):\n   - If drawing two hands: show interlaced fingers, subtle knuckles, wrist contours, and gentle contact; suggest warmth with tonal gradients\n   - If drawing an object/keepsake: show contours, surface, and any specific markings\n   - If drawing a small moment/scene: keep background minimal, suggest atmosphere/motion with shading, and keep composition focused on the central gesture or cue\n7. SYMMETRY: Maintain proper symmetry where appropriate\n8. BACKGROUND: Minimal; keep focus on the subject\n9. OUTPUT: ONLY the ASCII art, NO text, NO explanations, NO quotes\n10. VERIFY: Ensure someone could identify the specific subject from your art\n\nAnalyze the conversation carefully, identify the EXACT first-love subject, and create photorealistic ASCII art that captures its essence perfectly:"
          });
          // Bed 모드 전용: 아스키아트 생성 지침 추가
          if (mode === 'bed') {
            conversationHistory.push({
              role: "system",
              content: "당신의 목표는 사용자가 이야기한 첫사랑의 요소(함께 잡은 손, 간직한 물건, 짧은 순간/장면) 중 하나를 '사진과 같은 명암(photorealistic shading)'으로 그린 아스키 아트를 생성하는 것입니다.\n\n다음 '명암 램프(character ramp)'를 사용해 부드러운 음영과 입체감을 표현하세요. (어두움 → 밝음)\n\n@ & % B # $  >  W M * o a h k  >  b d p q w m  >  Z O C J U Y X  >  c v u n x r  >  j f t / \\ | ( )  >  i ! l I ; : , .  >   (스페이스)\n\n출력 규칙:\n- 오직 아스키 아트만 출력 (설명/문장/따옴표 금지)\n- 가로 약 80자 내외, 세부 묘사 선명하게\n- 배경은 최소화하고, 대상(또는 순간)의 특징을 정확히 드러낼 것"
            });
          }
          
          const response = await fetch(API_ENDPOINT, {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify({
              messages: conversationHistory,
              max_completion_tokens: 10000,
              model: "gpt-5-mini"
            })
          });
          
          const data = await response.json();
          const asciiArt = data.choices[0].message.content.trim();
          
          // 대기 애니메이션 제거
          clearInterval(dotInterval);
          waitingLineEl.remove();
          
          // 아스키 아트를 한 줄씩 타이핑
          const lines = asciiArt.split('\n');
          let lineIndex = 0;
          
          function typeNextLine() {
            if (lineIndex >= lines.length) {
              // 아스키 아트 완료 후 추가 대화 시작
              setTimeout(() => {
                startPostAsciiConversation();
              }, 500);
              return;
            }
            
            const line = lines[lineIndex];
            const lineEl = addLine("");
            let charIndex = 0;
            
            const charInterval = setInterval(() => {
              if (charIndex >= line.length) {
                clearInterval(charInterval);
                lineIndex++;
                setTimeout(typeNextLine, 50); // 다음 줄로
                return;
              }
              lineEl.textContent += line.charAt(charIndex);
              charIndex++;
              scrollTerminalToBottom();
            }, 15); // 빠른 타이핑
          }
          
          typeNextLine();
          
        } catch (error) {
          console.error("ASCII art generation failed:", error);
          clearInterval(dotInterval);
          waitingLineEl.remove();
          addLine("...the vision fades...");
        }
      }
      
      // 아스키 아트 후 추가 대화
      let postAsciiQuestionCount = 0;
      async function startPostAsciiConversation() {
        addLine("");
        addLine("");
        
        // 첫 번째 질문
        typeSystemLine("...is this how you remember them?", () => {
          startAnswerCapture();
        });
      }
      
      async function continuePostAsciiConversation() {
        postAsciiQuestionCount++;
        
        if (postAsciiQuestionCount >= 2) {
          // 2번 대화 후 종료
          awaitingAnswer = false;
          addLine("");
            addLine("");
            addLine("");
            typeSystemLine("... but it's time to go to bed", () => {
              setTimeout(() => {
                enterMoonSimpleMode();
              }, 3000);
            });
          
          return;
        }
        
        // AI에게 다음 질문 요청
        try {
          conversationHistory.push({
            role: "system",
            content: "Based on the user's response about their memory, ask ONE short, reflective follow-up question. Keep it brief, philosophical, and gentle. Start with '...' Examples: '...and does it still bring you comfort?', '...do you wish you could return to that time?', '...what feeling does it evoke now?'"
          });
          
          const waitingLineEl = addLine("");
          let dotCount = 0;
          const dotInterval = setInterval(() => {
            dotCount = (dotCount + 1) % 4;
            waitingLineEl.textContent = '.'.repeat(dotCount);
          }, 500);
          
          const response = await fetch(API_ENDPOINT, {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify({
              messages: conversationHistory,
              max_completion_tokens: 1000,
              model: "gpt-5-mini"
            })
          });
          
          const data = await response.json();
          const questionText = data.choices[0].message.content.trim();
          
          conversationHistory.push({
            role: "assistant",
            content: questionText
          });
          
          clearInterval(dotInterval);
          waitingLineEl.remove();
          
          typeSystemLine(questionText, () => {
            startAnswerCapture();
          });
          
        } catch (error) {
          console.error("Post-ASCII conversation failed:", error);
          clearInterval(dotInterval);
          awaitingAnswer = false;
          addLine("...the connection fades...");
        }
      }

      function queueChar(ch) {
        pendingChars.push(ch);
        if (!typingTicker) {
          typingTicker = setInterval(() => {
            if (pendingChars.length === 0) {
              clearInterval(typingTicker);
              typingTicker = null;
              return;
            }
            const nextChar = pendingChars.shift();
            userBuffer += nextChar;
            updateAnswerDisplay();
          }, 30);
        }
      }

      function handleTerminalBackspace() {
        if (pendingChars.length > 0) {
          pendingChars.pop();
          return;
        }
        if (userBuffer.length > 0) {
          userBuffer = userBuffer.slice(0, -1);
          updateAnswerDisplay();
        }
      }

      function finalizeAnswerAndNextQuestion() {
        // pendingChars 남은 거 마저 반영
        while (pendingChars.length > 0) {
          const nextChar = pendingChars.shift();
          userBuffer += nextChar;
        }
        if (typingTicker) {
          clearInterval(typingTicker);
          typingTicker = null;
        }

        // 커서를 제거하고 최종 답변만 표시
        if (currentAnswerEl) {
          currentAnswerEl.textContent = answerPrefix + userBuffer;
        }

        // 사용자 답변을 대화 기록에 추가
        if (userBuffer.trim()) {
          conversationHistory.push({
            role: "user",
            content: userBuffer
          });
        }

        awaitingAnswer = false;
        userBuffer = ""; // 버퍼 초기화
        
        // 아스키 아트 이후 대화인지 확인
        if (questionIndex >= 5) {
          // 아스키 아트 후 추가 대화
          continuePostAsciiConversation();
        } else {
          // 일반 질문 진행
          questionIndex++; // 다음 질문으로
          askNextQuestion();
        }
      }

      // ====== 키보드 입력 ======
      document.addEventListener('keydown', (event) => {
        // 첫 타이핑 시 모든 온보딩 힌트 제거 (영구)
        if (event.key && event.key.length === 1 && !event.ctrlKey && !event.metaKey) {
          if (!typeHintDismissed) {
            if (hintType && hintType.classList.contains('visible')) hideHint(hintType);
            typeHintDismissed = true;
          }
          if (!scrollHintDismissed) {
            if (hintScroll && hintScroll.classList.contains('visible')) hideHint(hintScroll);
            scrollHintDismissed = true;
          }
          if (!dragHintDismissed) {
            if (hintDrag && hintDrag.classList.contains('visible')) hideHint(hintDrag);
            dragHintDismissed = true;
          }
        }
        // ===== moon 모드 입력 =====
        if (mode === 'moon') {
          // (변경) 카운트다운 이후 Enter 불필요 → 자동 축소 및 입력 유도
          // 최종 선택 입력 처리
          if (moonAwaitingFinalDecision) {
            if (event.key === 'Enter') {
              event.preventDefault();
              const decision = moonInputBuffer.trim();
              if (!decision) return;
              moonAwaitingFinalDecision = false;
              moonAwaitingType = false;
              setMoonPrompt("");
              // 대화 기록에 사용자 응답 추가
              moonHistory.push({ role: 'user', content: decision });
              // 분기
              if (isPositiveResponse(decision)) {
                enterSunMode();
              } else {
                resetToNormal();
              }
              return;
            }
            if (event.key === 'Backspace') {
              event.preventDefault();
              if (moonInputBuffer.length > 0) {
                moonInputBuffer = moonInputBuffer.slice(0, -1);
                typingIndicator.textContent = moonInputBuffer || 'TYPE';
                if (moonInputBuffer) typingIndicator.classList.remove('typing-big');
                else typingIndicator.classList.add('typing-big');
              }
              return;
            }
            if (event.key.length === 1 && !event.ctrlKey && !event.metaKey) {
              event.preventDefault();
              moonInputBuffer += event.key;
              typingIndicator.textContent = moonInputBuffer;
              typingIndicator.classList.remove('typing-big');
              return;
            }
          }

          if (moonAwaitingSecondEnter) {
            if (event.key === 'Enter') {
              event.preventDefault();
              moonAwaitingSecondEnter = false;
              clearMoonEnterPrompt();
              setMoonPrompt("");
              // 두 번째 답변 출력
              handleMoonSecondReply(moonInputBuffer);
            }
            return;
          }
          if (moonAwaitingEnter) {
            if (event.key === 'Enter') {
              event.preventDefault();
              moonAwaitingEnter = false;
              clearMoonEnterPrompt();
              setMoonPrompt("");
              // 다음 줄로 진행하거나, 입력 단계로
              moonStep++;
              if (moonStep < moonLines.length - 1) {
                // 다음 고정 문장
                showMoonText(moonLines[moonStep]);
                // 계속 엔터 대기
                moonAwaitingEnter = true;
                setMoonPrompt('');
                scheduleMoonEnterPrompt();
              } else {
                // "wish to the stars" 이후: AI 로직 제거 → 5초 카운트다운 후 Enter 대기
                showMoonText(moonLines[moonStep]);
                startMoonFinalCountdown(5);
              }
            }
            return;
          }
          if (moonAwaitingType) {
            if (event.key === 'Enter') {
              event.preventDefault();
              const wish = moonInputBuffer.trim();
              if (!wish) return; // 빈 입력 무시
              if (moonAwaitingWishSentence) {
                // 카운트다운 이후 소원 문장 입력 완료 → 링 생성 후 Sun 모드로 전환
                moonAwaitingWishSentence = false;
                moonAwaitingType = false;
                clearMoonTypePrompt();
                setMoonPrompt("");
                createRingFromSentence(wish);
                // 원상 복귀 크기로 부드럽게 확대
                targetSphereScale = 1.0;
                // Sun 모드 진입 (오버레이 정리 포함)
                enterSunMode();
                return;
              }
              // (기존 Moon 대화 로직은 비활성화)
              return;
            }
            if (event.key === 'Backspace') {
              event.preventDefault();
              if (moonInputBuffer.length > 0) {
                moonInputBuffer = moonInputBuffer.slice(0, -1);
                typingIndicator.textContent = moonInputBuffer || 'TYPE';
                if (moonInputBuffer) typingIndicator.classList.remove('typing-big');
                else typingIndicator.classList.add('typing-big');
                // 카운트다운 이후엔 추가 프롬프트 스케줄 없음
              }
              return;
            }
            if (event.key.length === 1 && !event.ctrlKey && !event.metaKey) {
              event.preventDefault();
              moonInputBuffer += event.key;
              typingIndicator.textContent = moonInputBuffer;
              typingIndicator.classList.remove('typing-big');
              // 카운트다운 이후엔 추가 프롬프트 스케줄 없음
              return;
            }
          }
          // Moon mode에서 Enter 키를 눌렀을 때 (특별한 상태가 아닌 경우)
          if (event.key === 'Enter') {
            event.preventDefault();
            // center-content가 활성화된 경우 (enterMoonSimpleMode로 들어온 경우)
            if (centerContentEl.classList.contains('active')) {
              resetToNormal();
              return;
            }
            // 그 외의 경우도 첫 화면으로
            resetToNormal();
            return;
          }
          return;
        }
        if (mode === 'terminal') {
          // 터미널 모드 대화
          if (awaitingAnswer) {
            if (event.key === 'Enter') {
              event.preventDefault();
              // "exit" 입력시 moon mode로 전환
              if (userBuffer.trim().toLowerCase() === 'exit') {
                enterMoonSimpleMode();
                return;
              }
              finalizeAnswerAndNextQuestion();
              return;
            }
            if (event.key === 'Backspace') {
              event.preventDefault();
              handleTerminalBackspace();
              return;
            }
            if (event.key.length === 1 && !event.ctrlKey && !event.metaKey) {
              event.preventDefault();
              queueChar(event.key);
              return;
            }
          } else {
            // 질문 다 끝난 후의 입력 (exit만 허용)
            if (event.key === 'Enter') {
              event.preventDefault();
              // "exit" 입력시 moon mode로 전환
              if (userBuffer.trim().toLowerCase() === 'exit') {
                enterMoonSimpleMode();
                return;
              }
            } else if (event.key === 'Backspace') {
              event.preventDefault();
              if (userBuffer.length > 0) {
                userBuffer = userBuffer.slice(0, -1);
              }
            } else if (event.key.length === 1 && !event.ctrlKey && !event.metaKey) {
              event.preventDefault();
              userBuffer += event.key;
            }
          }
          return;
        }

        // ===== space / sun / bed 모드 =====

        if (event.key === 'Enter') {
          event.preventDefault();
        // Bed 모드: 엔터로도 모노리스 확대
        if (mode === 'bed') {
          if (!blackoutTriggered) {
            monolithSize += 5;
            const newW = monolithSize;
            const newH = monolithSize * 2;
            monolith.style.width = newW + 'px';
            monolith.style.height = newH + 'px';
            checkMonolithOverflow(newH);
          }
          return;
        }
          
          // center-content가 활성화된 상태에서 엔터 치면 첫 화면으로 (Moon mode 등)
          if (centerContentEl.classList.contains('active')) {
            if (mode === 'moon') {
              resetToNormal();
              return;
            }
            centerContentEl.classList.remove('active');
            centerContentEl.innerHTML = "";
            backHint.classList.remove('active');
            renderer.domElement.style.opacity = '1';
            // Star 오디오 정지
            if (starAudio) {
              starAudio.pause();
              starAudio.currentTime = 0;
              starAudio = null;
            }
            return;
          }
          
          const text = currentInput.trim();

          // 특수 명령 우선 처리
          const lowerText = text.toLowerCase();
          
          // 색상 명령 확인 (우선순위가 높음)
          if (setCustomSphereColor(lowerText)) {
            // 색상이 성공적으로 변경됨
          } else if (lowerText === 'sun') {
            enterSunMode();
          } else if (lowerText === 'bed') {
            enterBedMode();
          } else if (lowerText === 'star') {
            // Star: 소원/대화 모드 진입
            if (hintTypeStar) hideHint(hintTypeStar);
            if (starTypeHintTimeoutId) { clearTimeout(starTypeHintTimeoutId); starTypeHintTimeoutId = null; }
            if (starTypeHintAutoHideTimeoutId) { clearTimeout(starTypeHintAutoHideTimeoutId); starTypeHintAutoHideTimeoutId = null; }
            enterMoonMode();
          } else if (lowerText === 'moon') {
            // Moon: 간단 모드로 안전 전환 후 GIF 보여주기
            enterMoonSimpleMode();
          } else {
            // 일반 텍스트: 문장을 단어로 분리하여 각각 생성하되, 오른쪽으로 약간씩 치우치게 배치
            const words = text.split(/\s+/).filter(Boolean);
            const angleStep = 0.08; // 라디안 단위, 오른쪽 오프셋
            const downStep = 0.05; // 라디안 단위, 아래쪽(우하향) 기울기
            words.forEach((w, i) => {
              createTextOnSphere(w, i, angleStep, downStep);
            });
          }

          currentInput = "";
          typingIndicator.textContent = "";
          return;
        }

        if (event.key === 'Backspace') {
          event.preventDefault();

          if (mode === 'bed') {
            // [수정 3] bed 모드: monolith 수축 (중앙 기준)
            if (!blackoutTriggered) {
              monolithSize = Math.max(0, monolithSize - 5);
              const newW = monolithSize;
              const newH = monolithSize * 2;
              monolith.style.width = newW + 'px';
              monolith.style.height = newH + 'px';
            }
            return;
          }

          // space/sun: 현재 입력 버퍼 수정
          if (currentInput.length > 0) {
            currentInput = currentInput.slice(0, -1);
            typingIndicator.textContent = currentInput;
          }
          return;
        }

        if (event.key.length === 1 && !event.ctrlKey && !event.metaKey) {
          event.preventDefault();

          if (mode === 'bed') {
            // [수정 3] bed 모드: 타이핑할수록 monolith가 커짐 (중앙 기준)
            if (!blackoutTriggered) {
              monolithSize += 5; // 기본 크기 증가
              const newW = monolithSize;
              const newH = monolithSize * 2; // 1:2 비율
              monolith.style.width = newW + 'px';
              monolith.style.height = newH + 'px';
              checkMonolithOverflow(newH); // 높이 기준으로 체크
            }
            return;
          }

          // space/sun 모드: 그냥 입력 버퍼에 쌓음
          currentInput += event.key;
          typingIndicator.textContent = currentInput;
          return;
        }
      });

      // Star preset click (소원/대화 모드)
      if (starTriggerEl) {
        starTriggerEl.addEventListener('click', (e) => {
          e.preventDefault();
          enterMoonMode();
        });
      }
      // Sun preset click
      if (sunTriggerEl) {
        sunTriggerEl.addEventListener('click', (e) => {
          e.preventDefault();
          enterSunMode();
        });
      }
      // Moon preset click (간단 연출)
      if (moonTriggerEl) {
        moonTriggerEl.addEventListener('click', (e) => {
          e.preventDefault();
          enterMoonSimpleMode();
        });
      }
      // Bed preset click
      if (bedTriggerEl) {
        bedTriggerEl.addEventListener('click', (e) => {
          e.preventDefault();
          enterBedMode();
        });
      }
      // Top title click (첫 화면으로 복귀)
      if (topTitleEl) {
        topTitleEl.addEventListener('click', (e) => {
          e.preventDefault();
          resetToNormal();
        });
      }

      // ====== 애니메이션 루프 ======
      function animate() {
        requestAnimationFrame(animate);

        controls.update();

        const t = clock.getElapsedTime();

        // [수정 1] 부드러운 구체 스케일링 적용
        if (Math.abs(currentSphereScale - targetSphereScale) > 0.001) {
          const lerpFactor = introActive ? INTRO_SHRINK_LERP : NORMAL_SHRINK_LERP;
          currentSphereScale = THREE.MathUtils.lerp(currentSphereScale, targetSphereScale, lerpFactor);
          applySphereScale();
          // 도입 종료 조건: 충분히 목표 크기에 근접하면 종료
          if (introActive && Math.abs(currentSphereScale - targetSphereScale) < 0.02) {
            introActive = false;
          }
        }

        // 도입 중 약한 반시계 방향 회전 (Z축 기준)
        if (introActive) {
          sphere.rotation.z += INTRO_ROT_PER_FRAME; // counter-clockwise on screen
        }
        
        // 모션 블러 효과: 이전 회전 상태를 저장하고 블러 구체에 적용
        motionBlurSpheres.forEach((blurSphere, i) => {
          if (i === 0) {
            // 첫 번째 블러 구체는 이전 프레임의 회전 상태 저장
            previousSphereRotations[2].copy(previousSphereRotations[1]);
            previousSphereRotations[1].copy(previousSphereRotations[0]);
            previousSphereRotations[0].copy(sphere.rotation);
          }
          
          // 각 블러 구체에 이전 회전 상태 적용
          blurSphere.rotation.copy(previousSphereRotations[i]);
          blurSphere.scale.copy(sphere.scale);
        });

        // space 모드 idle 시: 구체를 조금 더 빠르게 천천히 회전
        if (mode === 'space' && currentInput.length === 0) {
          sphere.rotation.y += 0.0022;
        }

        // 별의 회전 / 반짝임
        starsGroup.rotation.y += 0.0006;
        starsGroup.rotation.x += 0.00025;

        tinyStars.material.opacity = 0.8 + Math.sin(t * 1.5) * 0.2;
        midStars.material.opacity  = 0.8 + Math.sin(t * 1.1 + 1.3) * 0.25;
        bigStars.material.opacity  = 0.9 + Math.sin(t * 0.8 + 2.1) * 0.2;
        
        // 구체 내부 별들: 구체 스케일에 따라 크기 조정
        innerStarsGroup.scale.set(currentSphereScale, currentSphereScale, currentSphereScale);
        innerStarsGroup.rotation.y += 0.0004;
        innerStarsGroup.rotation.x += 0.0002;
        
        // 투명도를 0.6 정도로 유지하되 약간의 깜빡임 효과
        innerTinyStars.material.opacity = 0.6 + Math.sin(t * 1.3 + 0.5) * 0.1;
        innerMidStars.material.opacity  = 0.6 + Math.sin(t * 0.9 + 1.8) * 0.1;
        innerBigStars.material.opacity  = 0.6 + Math.sin(t * 1.0 + 2.5) * 0.1;
        
        // Dots shrinking towards 0.5x size, then lock interaction
        if (dotsShrinkActive) {
          const allPoints = [tinyStars, midStars, bigStars, innerTinyStars, innerMidStars, innerBigStars];
          let allDone = true;
          allPoints.forEach(points => {
            const targetSize = (points.userData && points.userData.baseSize) ? points.userData.baseSize * 0.5 : points.material.size * 0.5;
            const currentSize = points.material.size;
            const nextSize = THREE.MathUtils.lerp(currentSize, targetSize, 0.07);
            points.material.size = nextSize;
            if (Math.abs(nextSize - targetSize) > 0.02) allDone = false;
          });
          if (allDone) {
            dotsShrinkActive = false;
            dotsShrinkDone = true;
            interactionLocked = true;
            controls.enabled = false;
          }
        }

        // 앵커 회전: space 모드에서는 항상 별의 회전을 따르고, 그 외엔 고전(구체) 방식
        if (mode === 'space') {
          textAnchor.rotation.copy(starsGroup.rotation);
        } else {
          textAnchor.rotation.copy(sphere.rotation);
        }

        // [수정 2] 텍스트 위치 및 크기 업데이트 로직
        textMeshes.forEach((textMesh) => {
          // 모든 텍스트의 크기를 구체 스케일에 맞춰 조정
          textMesh.scale.set(currentSphereScale, currentSphereScale, currentSphereScale);
          
          if (textMesh.userData.isFloating) {
            // Sun 모드: float away
            textMesh.position.lerp(
              textMesh.userData.targetPosition,
              textMesh.userData.floatSpeed
            );
            textMesh.rotation.x += textMesh.userData.rotationSpeed;
            textMesh.rotation.y += textMesh.userData.rotationSpeed * 0.7;
          } else if (textMesh.userData.isOrbiting) {
            // Sun 모드: 구 주변 공전
            const newRadius = getCurrentSurfaceRadius() + textMesh.userData.orbitRadiusOffset;
            const baseLocal = (textMesh.userData.localDirection || new THREE.Vector3(0,0,1)).clone();
            const yAxis = new THREE.Vector3(0,1,0);
            textMesh.userData.orbitAngle += textMesh.userData.orbitSpeed;
            const rotated = baseLocal.applyAxisAngle(yAxis, textMesh.userData.orbitAngle).normalize();
            textMesh.position.copy(rotated.clone().multiplyScalar(newRadius));
            const outwardWorld = textAnchor.localToWorld(rotated.clone().multiplyScalar(newRadius * 2));
            textMesh.lookAt(outwardWorld);
            textMesh.rotation.z += textMesh.userData.selfRotateSpeed * 0.5;
          } else {
            // Space 모드: 구체 표면에 붙어있기
            const newRadius = getCurrentSurfaceRadius();
            if (textMesh.parent === textAnchor && textMesh.userData.localDirection) {
              // 앵커 로컬 방향을 따라 반경만 업데이트
              const localDir = textMesh.userData.localDirection.clone();
              textMesh.position.copy(localDir.multiplyScalar(newRadius));
              const outwardWorld = textAnchor.localToWorld(textMesh.userData.localDirection.clone().multiplyScalar(newRadius * 2));
              textMesh.lookAt(outwardWorld);
              textMesh.userData.targetPosition.copy(textMesh.getWorldPosition(new THREE.Vector3()));
            } else {
              // 기존(레거시) 방식
              const newPosition = textMesh.userData.normalizedDirection.clone().multiplyScalar(newRadius);
              textMesh.position.copy(newPosition);
              const outwardDirection = newPosition.clone().multiplyScalar(2);
              textMesh.lookAt(outwardDirection);
              textMesh.userData.targetPosition.copy(newPosition);
            }
          }
        });

        // Sun 모드: 확대 임계치 이상일 때 preset 페이드아웃 및 대사 시퀀스
        if (mode === 'sun') {
          if (currentSphereScale >= SUN_PRESET_FADE_SCALE) {
            if (!sunPresetHidden && presetEl) {
              presetEl.style.opacity = '0';
              presetEl.style.pointerEvents = 'none';
              sunPresetHidden = true;
            }
            if (!sunZoomSequenceTriggered) {
              if (!sunZoomAboveSince) {
                sunZoomAboveSince = performance.now();
              } else if (performance.now() - sunZoomAboveSince >= 2000) {
                sunZoomSequenceTriggered = true;
                runSunZoomSequence();
              }
            }
          } else {
            sunZoomAboveSince = null;
            // 작아졌으면 preset 다시 표시
            if (presetEl && sunPresetHidden && currentSphereScale <= SUN_PRESET_SHOW_SCALE) {
              presetEl.style.opacity = '1';
              presetEl.style.pointerEvents = 'auto';
              sunPresetHidden = false;
            }
          }
          // 10초간 확대 입력 없으면 하단 힌트 표시
          const nowT = performance.now();
          if (!sunIdleHintVisible && (nowT - lastSunZoomChange >= 10000)) {
            if (sunIdleHintEl) sunIdleHintEl.classList.add('visible');
            sunIdleHintVisible = true;
          }
          // 확대 입력이 발생하면 wheel 핸들러에서 즉시 숨김 처리함
        } else if (mode === 'moon') {
          // Star(=Moon) 모드에서도 작아지면 preset 표시
          if (presetEl && currentSphereScale <= SUN_PRESET_SHOW_SCALE) {
            presetEl.style.opacity = '1';
            presetEl.style.pointerEvents = 'auto';
            sunPresetHidden = false;
          }
          sunZoomAboveSince = null;
          if (sunIdleHintVisible && sunIdleHintEl) {
            sunIdleHintEl.classList.remove('visible');
            sunIdleHintVisible = false;
          }
        } else {
          sunZoomAboveSince = null;
          if (sunIdleHintVisible && sunIdleHintEl) {
            sunIdleHintEl.classList.remove('visible');
            sunIdleHintVisible = false;
          }
        }

        renderer.render(scene, camera);
      }

      function runSunZoomSequence() {
        if (!centerContentEl) return;
        centerContentEl.classList.add('active');
        centerContentEl.innerHTML = "";

        const msg1 = document.createElement('div');
        msg1.className = 'fade-msg';
        msg1.textContent = 'Why are you still not sleeping?';
        centerContentEl.appendChild(msg1);
        // fade-in
        requestAnimationFrame(() => { msg1.style.opacity = '1'; });
        // fade-out after ~2s
        setTimeout(() => { msg1.style.opacity = '0'; }, 2000);

        // after 3.2s, show second message
        setTimeout(() => {
          centerContentEl.innerHTML = "";
          const msg2 = document.createElement('div');
          msg2.className = 'fade-msg';
          const base = "...if you don't go to bed early";
          const span = document.createElement('span');
          span.textContent = base;
          const dots = document.createElement('span');
          dots.textContent = '';
          msg2.appendChild(span);
          msg2.appendChild(dots);
          centerContentEl.appendChild(msg2);
          // fade-in
          requestAnimationFrame(() => { msg2.style.opacity = '1'; });
          // dots typing
          let dotCount = 0;
          const dotIv = setInterval(() => {
            if (dotCount >= 3) { clearInterval(dotIv); return; }
            dots.textContent += '.';
            dotCount++;
          }, 600);
          // fade-out after ~2.4s
          setTimeout(() => { msg2.style.opacity = '0'; }, 2400);
          // after ~3.2s go to bed
          setTimeout(() => {
            centerContentEl.classList.remove('active');
            centerContentEl.innerHTML = "";
            enterBedMode();
          }, 3200);
        }, 3200);
      }

      // 리사이즈 대응
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      animate();

      // ====== 온보딩: 드래그/스크롤 힌트 ======
      // 힌트 1회성 표시 제어 플래그
      let dragHintDismissed = false;
      let scrollHintDismissed = false;
      let typeHintDismissed = false;
      let starTypeHintTimeoutId = null;
      let starTypeHintShown = false;
      let starTypeHintAutoHideTimeoutId = null;
      let scrollHintAutoHideTimeoutId = null;
      let dragHintAutoHideTimeoutId = null;

      function showHint(el) {
        if (!el) return;
        el.classList.add('visible');
      }
      function hideHint(el) {
        if (!el) return;
        el.classList.remove('visible');
      }

      // 초기 도입: 먼저 Scroll 힌트 표시
      setTimeout(() => {
        if (!scrollHintDismissed) {
          showHint(hintScroll);
          // 10초 후 자동으로 페이드아웃
          scrollHintAutoHideTimeoutId = setTimeout(() => {
            if (hintScroll && mode === 'space') {
              hideHint(hintScroll);
            }
          }, 10000);
        }
      }, 600);

      // 30초 후: 여전히 space 모드, Star 미진입이면 'Type Star' 표시
      starTypeHintTimeoutId = setTimeout(() => {
        if (mode === 'space' && !starTypeHintShown) {
          if (hintTypeStar) {
            showHint(hintTypeStar);
            starTypeHintShown = true;
            // 10초 후 자동으로 페이드아웃
            starTypeHintAutoHideTimeoutId = setTimeout(() => {
              if (hintTypeStar && mode === 'space') {
                hideHint(hintTypeStar);
              }
            }, 10000);
          }
        }
      }, 30000);

      // 드래그 감지 시: Drag 힌트 제거 후 Type 힌트 표시 (단, Scroll이 먼저 끝난 뒤)
      controls.addEventListener('start', () => {
        // 도입 종료 (사용자 인터랙션 발생)
        introActive = false;
        if (mode !== 'space') return;
        if (!scrollHintDismissed) return; // 순서 유지: Scroll 이후에 동작
        if (hintDrag && hintDrag.classList.contains('visible')) {
          hideHint(hintDrag);
          dragHintDismissed = true; // 다시는 표시하지 않음
          // 자동 숨김 타이머 클리어
          if (dragHintAutoHideTimeoutId) {
            clearTimeout(dragHintAutoHideTimeoutId);
            dragHintAutoHideTimeoutId = null;
          }
        } else {
          dragHintDismissed = true;
        }
        setTimeout(() => {
          if (mode === 'space' && hintType && !hintType.classList.contains('visible') && !typeHintDismissed) {
            showHint(hintType);
          }
        }, 250);
      });
    </script>
  </body>
</html>
